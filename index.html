<!DOCTYPE html>
<html>
<head>
  <title>Word Play Solver</title>
  <style>
    .table-grid {
      border-collapse: collapse;
      margin-bottom: 2em;
      table-layout: fixed;
    }

    .table-results {
      font-family: 'courier new', monospace;
      border-collapse: collapse;
      margin-bottom: 2em;
      table-layout: fixed;
      width: 40em;
    }

    th,
    td {
      border: 1px solid #ddd;
      width:2em;
      height:2em;
      padding: 8px;
      text-align: center;
      white-space: nowrap;
    }

    th {
      background-color: #4CAF50;
      color: #fff;
    }
  </style>
</head>

<body>

  <h1>Word Play Solver</h1>

  <h3> File handling </h3>
  Word count: <label id="filewordscount"> 0 </label>
  <input id="filewords" type="file"><br>
  <label for="filewords">
    Upload your "resources.assets" file from your "Word Play/Word Play_Data"
    install
  </label><br>

  <!--
  <input type="checkbox" id="extratile1" name="extratile1" value="extra1">
  <label for="extratile1"> Extra tile</label>
  <input type="checkbox" id="extratile2" name="extratile2" value="extra2" disabled>
  <label for="extratile2"> Extra tile</label>
  <input type="checkbox" id="extratile3" name="extratile3" value="extra3" disabled>
  <label for="extratile3"> Extra tile</label><br/><br/>
  -->

  <h3> Special modifiers </h3>
  <input type="checkbox" id="firstvowel" name="firstvowel"
    value="flagfirstvowel">
  <label for="firstvowel"> First letter is a vowel</label><br>
  <input type="checkbox" id="startsendssame" name="startsendssame"
    value="flagstartsendssame">
  <label for="startsendssame"> Starts and ends with same letter</label><br>
  <input type="checkbox" id="consecutivesame" name="consecutivesame"
    value="flagconsecutivesame">
  <label for="consecutivesame"> Two consecutive repeated letter</label><br>

  <h3> Input </h3>
  <input id="lineinput" placeholder="Available tiles" name="lineinput" />
  <button id="linesubmit">Submit!</button>

  <table id="tabletiles" class="table-grid">
    <tr>
      <td> 17 </td>
      <td> 1 </td>
      <td> 2 </td>
      <td> 3 </td>
      <td> 4 </td>
    </tr>
    <tr>
      <td> 18 </td>
      <td> 5 </td>
      <td> 6 </td>
      <td> 7 </td>
      <td> 8 </td>
    </tr>
    <tr>
      <td> 19 </td>
      <td> 9 </td>
      <td> 10 </td>
      <td> 11 </td>
      <td> 12 </td>
    </tr>
    <tr>
      <td> - </td>
      <td> 13 </td>
      <td> 14 </td>
      <td> 15 </td>
      <td> 16 </td>
    </tr>
  </table>

  <input type="checkbox" id="starttilesselector" name="starttilesselector"
    value="flagstarttilesselector">
  <label for="starttilesselector"> Starts with letter</label>
  <input id="startstiles" placeholder="Start tiles" name="linestarttiles"
    disabled/>

  <h2> Best words </h2>
  <table id="tablewords" class="table-results">
    <tr>
      <td> Word </td>
      <td> Total Score </td>
      <td> Letter Score </td>
      <td> Extra Score </td>
    </tr>
  </table>

  <script>
////////////////////////////////////////////////////////////////////////////////
// Config settings
////////////////////////////////////////////////////////////////////////////////
    const VALID_LETTERS = new Set('ABCDEFGHIJKLMNOPQRSTUVWXYZ*');
    const SEARCH_LETTERS = new Set('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
    const WORD_LENGTH_THRESHOLD = 3;

////////////////////////////////////////////////////////////////////////////////
// Global variables
////////////////////////////////////////////////////////////////////////////////
    // This represent the current searchable space of possibilities once
    // initialized
    let WORD_LIST = new Set();
    let WORD_TREE = new Map();

////////////////////////////////////////////////////////////////////////////////
// Word scoring constants
////////////////////////////////////////////////////////////////////////////////
    const VOWELS = new Set("AEIOU");
    const LONG_TILES = ["QU", "ING"];
    const TILE_SCORE = {
      'A': 1,
      'B': 3,
      'C': 3,
      'D': 2,
      'E': 1,
      'F': 4,
      'G': 2,
      'H': 4,
      'I': 1,
      'J': 8,
      'K': 5,
      'L': 1,
      'M': 3,
      'N': 1,
      'O': 1,
      'P': 3,
      'Q': 10,
      'R': 1,
      'S': 1,
      'T': 1,
      'U': 1,
      'V': 4,
      'W': 4,
      'X': 8,
      'Y': 4,
      'Z': 10,
    // Special characters
      '*': 0,
    // Also include multi-tile
      'QU': 10,
      'ING': 8,
    };
    const WORD_LENGTH_SCORE = {
      1: 0,
      2: 0,
      3: 0,
      4: 0,
      5: 5,
      6: 10,
      7: 15,
      8: 20,
      9: 30,
      10: 50,
      11: 70,
      12: 90,
      13: 110,
      14: 130,
      15: 150,
      16: 170,
      17: 190,
      18: 210,
      19: 230,
      20: 250,
      21: 270,
    };

////////////////////////////////////////////////////////////////////////////////
// Word scoring logic
////////////////////////////////////////////////////////////////////////////////
    const firstvowelinstance = document.getElementById("firstvowel");
    //console.log("firstvowel", firstvowelinstance.checked);
    const startsendssameinstance = document.getElementById("startsendssame");
    //console.log("startsendssame", startsendssameinstance.checked);
    const consecutivesameinstance = document.getElementById("consecutivesame");
    //console.log("consecutivesame", consecutivesameinstance.checked);

    function scoreWordByTiles(wordTiles) {
      let total = 0;
      for (let currentTile of wordTiles) {
        if (!(currentTile in TILE_SCORE)) {
          throw new Error(`Tile: ${currentTile} unknown. Not in TILE_SCORE`);
        }
        total += TILE_SCORE[currentTile];
      }
      return total;
    }

    function scoreWordByExtras(wordTiles) {
      let score = WORD_LENGTH_SCORE[wordTiles.length];
      if (firstvowelinstance.checked) {
        if (VOWELS.has(wordTiles[0])) {
          score = score * 2;
        }
      }
      if (startsendssameinstance.checked) {
        if (wordTiles[0] == wordTiles.at(-1)) {
          score = score * 2;
        }
      }
      if (consecutivesameinstance.checked) {
        const word = wordTiles.join("");
        const wordLengthLimit = word.length -1;
        for(let idx = 0; idx < wordLengthLimit ; idx++) {
          if (word[idx] == word[idx+1]) {
            score = score * 2;
            break;
          }
        }
      }
      return score;
    }

    function scoreWordOverall(wordTiles) {
      return scoreWordByTiles(wordTiles) +
        scoreWordByExtras(wordTiles);
    }

////////////////////////////////////////////////////////////////////////////////
// Word graph logic
////////////////////////////////////////////////////////////////////////////////

    function cloneArrayRemoveInstance(originalArray, element) {
        let nextOriginalArray = originalArray.slice(0);
        nextOriginalArray.splice(
          nextOriginalArray.indexOf(currentTile),
          1
        );
        return nextOriginalArray;
    }

    function sortByScoreOverallDescending(a, b) {
      const as = a.scoreOverall;
      const bs = b.scoreOverall;
      // First by score
      let res = as < bs;
      if (as == bs) {
        // If they are equals, sort by word
        res = a.word > b.word;
      }
      return res;
    }


    // This function will return the sorted array of words and values
    function transformAnswersToSortedArray(answers) {
      let arr = [];
      for (const currentWord in answers) {
        const currentAnswerStruct = answers[currentWord];
        let currentTiles = currentAnswerStruct["tiles"];
        arr.push({
          "word": currentWord,
          "tiles": currentTiles,
          "scoreOverall": scoreWordOverall(currentTiles),
          "scoreTiles": scoreWordByTiles(currentTiles),
          "scoreWordByExtras": scoreWordByExtras(currentTiles)
        })
      }
      arr.sort(sortByScoreOverallDescending);
      // Uncomment to see the sorted array of words
      //console.log(arr);
      return arr;
    }


    // Main logic of all this system, traverse the complete graph and return
    // the reachable words from the full pool of possibilities
    // This function does not return any value, it is set in the parameter
    // resultMap,
    function treeSearchRecursive(
      currentTree,
      availableTiles,
      seenWords,
      currentWord,
      currentWordTiles,
      resultMap
    ) {
      // Uncomment to see the recursion progress
      //console.log(`Recurse word: ${currentWord} tiles: ${currentWordTiles}`);

      // Basic backtracking concept, do not realize known work twice
      // The specific work is the word and the available tiles
      //   This is specially important for joker tiles
      const currentSituation = [currentWord, availableTiles];
      const currentScore = scoreWordOverall(currentWordTiles);
      if (currentSituation in seenWords) {
        return;
      }
      // We must add to the set in an array to prevent the set function from
      // splitting the string into characters
      seenWords.add([currentSituation]);

      if (WORD_LIST.has(currentWord)) {
        let writeWord = true;
        if (currentWord in resultMap) {
          // If the score we had is worse than the current
          if (resultMap[currentWord][0] > currentScore) {
            writeWord = false;
          }
        }
        if (writeWord) {
          // Uncomment line below to see which words have been written to the
          // results
          //console.log(`Added word: ${currentWord} tiles: ${currentWordTiles}`);
          resultMap[currentWord] = {
            "score": currentScore,
            "tiles": currentWordTiles
          };
        }
      }

      // Debug to check the progress of the search
      //console.log("Recursed tile", currentWord, WORD_LIST.has(currentWord));
      for(currentTile of new Set(availableTiles)) {
        // The logic to add the current tile to the array is shared
        let nextWordTiles = currentWordTiles.slice();
        nextWordTiles.push(currentTile);

        // First scenario, the joker
        if (currentTile == "*") {
          let nextTiles = cloneArrayRemoveInstance(availableTiles, currentTile);
          for (possibleTile of SEARCH_LETTERS) {
            if (possibleTile in currentTree) {
              treeSearchRecursive(
                currentTree[possibleTile],
                nextTiles,
                seenWords,
                currentWord + possibleTile,
                nextWordTiles,
                resultMap
              );
            }
          }
          continue;
        // Second scenario, a tile
        } else {
          let currentWordTree = currentTree;
          // Search block
          let validStart = true;
          // Search for the start sequence
          for(letter of currentTile) {
            if (letter in currentWordTree) {
              currentWordTree = currentWordTree[letter];
            } else {
              validStart = false;
              break;
            }
          }
          // If the start is valid
          //   we already know the subtree location and can jump directly
          if (validStart) {
            let nextTiles = cloneArrayRemoveInstance(
              availableTiles,
              currentTile
            );
            treeSearchRecursive(
              currentWordTree,
              nextTiles,
              seenWords,
              currentWord + currentTile,
              nextWordTiles,
              resultMap
            );
          }
        }
      }
    }

    // This function is the entry point, setting the recursive needed variables
    // for the main logic
    function treeSearch(availableLetters) {
      let tiles = availableLettersTileizer(availableLetters);
      // Sort to have an stable search, making all tiles of the same value
      // interchangable
      tiles.sort();
      //console.log("Sorted tiles", tiles);
      let seen = new Set();
      let result = new Map();
      treeSearchRecursive(
        WORD_TREE,
        tiles,
        seen,
        "",
        [],
        result
      );
      // Uncomment to see the answers generated by the algorithm
      // Be warned! There can be MANY answers.
      //console.log(result);
      return transformAnswersToSortedArray(result);
    }

////////////////////////////////////////////////////////////////////////////////
// Word logic
////////////////////////////////////////////////////////////////////////////////

    function tileToLetters(tile) {
      let letterSeq = tile;
      if (letterSeq.length > 1) {
        letterSeq = tile.split('');
      } else if (tile == "*") {
        letterSeq = SEARCH_LETTERS;
      }
      return letterSeq;
    }

    // This function splits the string of letters inputted by the user into
    // an array of tiles for the logic to utilize afterwords.
    function availableLettersTileizer(availableLetters) {
      let resultTiles = [];
      availableLetters = availableLetters.toUpperCase();
      const splitAvailableLetters = availableLetters.split('');
      // Traverse the full array of characters
      for(let idx = 0; idx<splitAvailableLetters.length ; idx++) {
        let specialSeqFound = false;
        // Check at the current position if it is a special sequence
        for(const specialSeq of LONG_TILES) {
          if (availableLetters.indexOf(specialSeq, idx) == idx) {
            // Add the special sequence to the result
            resultTiles.push(specialSeq);
            // Advance forward the extra letters
            idx += specialSeq.length -1;
            specialSeqFound = true;
            break;
          }
        }
        // If not a special sequence add the character to the list
        if (! specialSeqFound) {
          const curLet = splitAvailableLetters[idx];
          resultTiles.push(curLet);
        }
      }
      return resultTiles;
    }

    function validateWord(possibleWord) {
      if (possibleWord.length >= WORD_LENGTH_THRESHOLD) {
        // If the word is valid, add it to the list
        WORD_LIST.add(possibleWord);
        // Also add it to the tre of possibilities
        let currentWordTree = WORD_TREE;
        // The logic of the loop is just to generate the tree of
        // possibilities. For that letter by letter we add them
        // to the space linking forwards.
        for (wordletter of possibleWord) {
          if (! (wordletter in currentWordTree)) {
            currentWordTree[wordletter] = new Map();
          }
          currentWordTree = currentWordTree[wordletter];
        }
      }
    }

////////////////////////////////////////////////////////////////////////////////
// File loading logic
////////////////////////////////////////////////////////////////////////////////
    const filewordsinstance = document.getElementById("filewords");
    const filewordscountinstance = document.getElementById("filewordscount");
    filewordsinstance.addEventListener("change", filewordshandler);
    const fileprogressbarinstance = document.getElementById("fileprogressbar");

    // In this function we pre-process the file and optimize the information
    // into a format far more efficient for the processing we want to realize
    // with it.
    function processFileWords(rawtext) {
      let currentWord = "";
      for (let letter of rawtext) {
        // Logic is fairly simple, check if any byte/letter read is valid, and
        // if so add it to the current string, else validate the current
        // string.
        if (VALID_LETTERS.has(letter)) {
          currentWord += letter;
        } else {
          validateWord(currentWord);
          currentWord = "";
        }
      }
      filewordscountinstance.innerHTML = WORD_LIST.size;
      // Uncomment the line after to see the tree structure of all the
      // letters and theirs possible continuations.
      //console.log(WORD_TREE);
    }

    function processFileWordsCB(e) {
        processFileWords(e.target.result);
    }

    function readFileWords(file) {
      const info = `File Name: "${file.name}" File Size: ${file.size}B`;
      // Debug log just to confirm the correct data is being read
      //console.log(info);
      const reader = new FileReader();
      reader.onload = processFileWordsCB;
      reader.readAsText(file);
    }

    function filewordshandler(e) {
      WORD_TREE = new Map();
      WORD_LIST = new Set();
      const file = e.target.files[0];
      readFileWords(file);
    }

    // If already selected load the file
    if (filewordsinstance.files[0]) {
      readFileWords(filewordsinstance.files[0]);
    }

////////////////////////////////////////////////////////////////////////////////
// Display and event logic
////////////////////////////////////////////////////////////////////////////////
    const lineinputinstance = document.getElementById("lineinput");
    lineinputinstance.addEventListener("input", lineInputListener);

    const buttonlinessubmit = document.getElementById("linesubmit");
    buttonlinessubmit.onclick = lineInputSumbmit;
    const tabletilesinstance = document.getElementById("tabletiles");
    const tablewordsinstance = document.getElementById("tablewords");

    // Initializations from cached data
    lineInputGridDisplay(lineinputinstance.value);

    function displayAnswers(answers) {
      // First cleanup old answers
      while(tablewordsinstance.rows.length > 1) {
        tablewordsinstance.deleteRow(1);
      }
      for(const resultWord of answers) {
        // Uncomment to debug the row to be displayed
        //console.log(row);
        let tableRow = tablewordsinstance.insertRow(-1);
        let resultWordVals = [
          resultWord.word,
          resultWord.scoreOverall,
          resultWord.scoreTiles,
          resultWord.scoreWordByExtras
        ];
        for(const val of resultWordVals) {
          let tableRowCell = tableRow.insertCell(-1);
          tableRowCell.innerHTML = val;
        }
      }
    }

    function lineInputSumbmit(e) {
      if (WORD_LIST.size == 0) {
        alert("No file selected!");
        return;
      }
      let answers = treeSearch(lineinputinstance.value);
      displayAnswers(answers);
    }

    function lineInputGridDisplay(availableLetters) {
      const LETTERS_LENGTH_LINE = 23;
      let rownum = 0;
      let colnum = 1;
      const gridLenght = 16;
      const colstart = 1;
      const colwidth = 5;

      let letters = availableLettersTileizer(availableLetters);

      // Put the number of the position where there is no letter
      let counterPos = 1;

      // Fill the table
      for(let idx = 0; idx<gridLenght; idx++) {
        let ltr = counterPos++;
        if (idx < letters.length) {
          ltr = letters[idx];
        }
        tabletilesinstance.rows[rownum].cells[colnum++].innerHTML = ltr;
        if (colnum >= colwidth) {
          colnum = colstart;
          rownum++;
        }
      }

      // For the last 3 letters are the first column of the first three rows
      // For that, we manage them differently
      for(let idx=0; idx<3; idx++) {
        const pos=gridLenght+idx;
        let ltr = counterPos++;
        if(letters.length > pos) {
          ltr = letters[pos];
        }
        tabletilesinstance.rows[idx].cells[0].innerHTML = ltr;
      }

      // Limit the letter count, still thinking if this is too strict
      if(letters.length > LETTERS_LENGTH_LINE) {
        while(letters.length > LETTERS_LENGTH_LINE) {
          letters.pop();
        }
      }
      lineinputinstance.value = letters.join("");
    }

    function lineInputListener(e) {
      // Store the cursor positions
      var cursorStart = e.target.selectionStart,
        cursorEnd = e.target.selectionEnd;
      lineInputGridDisplay(e.target.value);
      // Restore them after the function calls
      e.target.setSelectionRange(cursorStart, cursorEnd);
    }

    // Starts with tiles selector logic
    const starttilesselectorinstance = document.getElementById(
      "starttilesselector"
    );
    const startstilesinstance = document.getElementById("startstiles");
    starttilesselectorinstance.addEventListener("click",
      startsWithtilesHandler
    );
    function startsWithtilesHandler(e) {
      startstilesinstance.toggleAttribute("disabled");
      if (startstilesinstance.hasAttribute("disabled")) {
        startstilesinstance.value = "";
      }
    }

  </script>
</body>
</html>
