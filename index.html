<!DOCTYPE html>
<html>
<head>
  <title>Word Play Solver</title>
  <style>
    .table-grid {
      border-collapse: collapse;
      margin-bottom: 2em;
      table-layout: fixed;
    }

    .table-results {
      border-collapse: collapse;
      margin-bottom: 2em;
      table-layout: fixed;
      width: 30em;
    }

    th,
    td {
      border: 1px solid #ddd;
      width:2em;
      height:2em;
      padding: 8px;
      text-align: center;
      white-space: nowrap;
    }

    th {
      background-color: #4CAF50;
      color: #fff;
    }
  </style>
</head>

<body>

  <h1>Word Play Solver</h1>

  <h3> File handling </h3>
  Word count: <label id="filewordscount"> 0 </label>
  <input id="filewords" type="file"><br>
  <label for="filewords">
    Upload your "resources.assets" file from your "Word Play/Word Play_Data"
    install
  </label><br>

  <!--
  <input type="checkbox" id="extratile1" name="extratile1" value="extra1">
  <label for="extratile1"> Extra tile</label>
  <input type="checkbox" id="extratile2" name="extratile2" value="extra2" disabled>
  <label for="extratile2"> Extra tile</label>
  <input type="checkbox" id="extratile3" name="extratile3" value="extra3" disabled>
  <label for="extratile3"> Extra tile</label><br/><br/>
  -->

  <h3> Special modifiers </h3>
  <input type="checkbox" id="firstvowel" name="firstvowel"
    value="flagfirstvowel">
  <label for="firstvowel"> First letter is a vowel</label><br>
  <input type="checkbox" id="startsendssame" name="startsendssame"
    value="flagstartsendssame">
  <label for="startsendssame"> Starts and ends with same letter</label><br>
  <input type="checkbox" id="consecutivesame" name="consecutivesame"
    value="flagconsecutivesame">
  <label for="consecutivesame"> Two consecutive repeated letter</label><br>

  <h3> Input </h3>
  <input id="lineinput" placeholder="Available tiles" name="lineinput" />
  <button id="linesubmit">Submit!</button>

  <table id="tabletiles" class="table-grid">
    <tr>
      <td> 17 </td>
      <td> 1 </td>
      <td> 2 </td>
      <td> 3 </td>
      <td> 4 </td>
    </tr>
    <tr>
      <td> 18 </td>
      <td> 5 </td>
      <td> 6 </td>
      <td> 7 </td>
      <td> 8 </td>
    </tr>
    <tr>
      <td> 19 </td>
      <td> 9 </td>
      <td> 10 </td>
      <td> 11 </td>
      <td> 12 </td>
    </tr>
    <tr>
      <td> - </td>
      <td> 13 </td>
      <td> 14 </td>
      <td> 15 </td>
      <td> 16 </td>
    </tr>
  </table>

  <input type="checkbox" id="starttilesselector" name="starttilesselector"
    value="flagstarttilesselector">
  <label for="starttilesselector"> Starts with letter</label>
  <input id="startstiles" placeholder="Start tiles" name="linestarttiles"
    disabled/>

  <h2> Best words </h2>
  <table id="tablewords" class="table-results">
    <tr>
      <td> Word </td>
      <td> Letter Score </td>
      <td> Extra Score </td>
    </tr>
  </table>

  <script>
////////////////////////////////////////////////////////////////////////////////
// Config settings
////////////////////////////////////////////////////////////////////////////////
    const VALID_LETTERS = new Set('ABCDEFGHIJKLMNOPQRSTUVWXYZ*');
    const SEARCH_LETTERS = new Set('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
    const WORD_LENGTH_THRESHOLD = 3;

////////////////////////////////////////////////////////////////////////////////
// Global variables
////////////////////////////////////////////////////////////////////////////////
    // This represent the current searchable space of possibilities once
    // initialized
    let WORD_LIST = new Set();
    let WORD_TREE = new Map();

////////////////////////////////////////////////////////////////////////////////
// Word scoring constants
////////////////////////////////////////////////////////////////////////////////
    const VOWELS = "AEIOU".split('');
    const SPECIAL_SEQUENCES = ["QU", "ING"];
    const LETTER_VALS = {
      'A': 1,
      'B': 3,
      'C': 3,
      'D': 2,
      'E': 1,
      'F': 4,
      'G': 2,
      'H': 4,
      'I': 1,
      'J': 8,
      'K': 5,
      'L': 1,
      'M': 3,
      'N': 1,
      'O': 1,
      'P': 3,
      'Q': 10,
      'R': 1,
      'S': 1,
      'T': 1,
      'U': 1,
      'V': 4,
      'W': 4,
      'X': 8,
      'Y': 4,
      'Z': 10,
    // Special characters
      '*': 0,
    // Also include multi-tile
      'QU': 10,
      'ING': 8,
    };
    const WORD_LENGTH_SCORE = {
      1: 0,
      2: 0,
      3: 0,
      4: 0,
      5: 5,
      6: 10,
      7: 15,
      8: 20,
      9: 30,
      10: 50,
      11: 70,
      12: 90,
      13: 110,
      14: 130,
      15: 150,
      16: 170,
      17: 190,
      18: 210,
      19: 230,
      20: 250,
      21: 270,
    };

////////////////////////////////////////////////////////////////////////////////
// Word scoring logic
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
// Word graph logic
////////////////////////////////////////////////////////////////////////////////

    function cloneArrayRemoveInstance(originalArray, element) {
        let nextOriginalArray = originalArray.slice(0);
        nextOriginalArray.splice(
          nextOriginalArray.indexOf(currentTile),
          1
        );
        return nextOriginalArray;
    }

    // Main logic of all this system, traverse the complete graph and return
    // the reachable words from the full pool of possibilities
    function treeSearchRecursive(
      currentTree,
      availableTokens,
      seenWords,
      currentWord
    ) {
      // Basic backtracking concept, do not realize known work twice
      // The specific work is the word and the available tokens
      //   This is specially important for joker tiles
      const currentSituation = [currentWord, availableTokens];
      if (currentSituation in seenWords) {
        return new Set();
      }
      // We must add to the set in an array to prevent the set function from
      // splitting the string into characters
      seenWords.add([currentSituation]);
      let resultSet = new Set();
      if (WORD_LIST.has(currentWord)) {
        resultSet.add([currentWord]);
      }
      // Debug to check the progress of the search
      //console.log("Recursed tile", currentWord, WORD_LIST.has(currentWord));

      for(currentTile of new Set(availableTokens)) {
        // First scenario, the joker
        if (currentTile == "*") {
          let nextTokens = cloneArrayRemoveInstance(tokens, currentTile);
          for (possibleTile of SEARCH_LETTERS) {
            if (possibleTile in currentTree) {
              resultSet = resultSet.union(
                treeSearchRecursive(
                  currentTree[possibleTile],
                  nextTokens,
                  seenWords,
                  currentWord + possibleTile
                )
              );
            }
          }
          continue;
        // Second scenario, a complex tile
        } else if (currentTile.length > 1) {
          let currentWordTree = currentTree;
          // Search block
          let validStart = true;
          // Search for the start sequence
          for(letter of currentTile) {
            if (letter in currentWordTree) {
              currentWordTree = currentWordTree[letter];
            } else {
              validStart = false;
              break;
            }
          }
          // If the start is valid
          //   we already know the subtree location and can jump directly
          if (validStart) {
            let nextTokens = cloneArrayRemoveInstance(
              availableTokens,
              currentTile
            );
            resultSet = resultSet.union(
              treeSearchRecursive(
                currentWordTree,
                nextTokens,
                seenWords,
                currentWord + currentTile
              )
            );
          }
        // Third scenario, a basic tile
        } else {
          if (currentTile in currentTree) {
            let nextTokens = cloneArrayRemoveInstance(
              availableTokens,
              currentTile
            );
            resultSet = resultSet.union(
              treeSearchRecursive(
                currentTree[currentTile],
                nextTokens,
                seenWords,
                currentWord + currentTile
              )
            );
          }
        }
      }
      return resultSet;
    }

    // This function is the entry point, setting the recursive needed variables
    // for the main logic
    function treeSearch(availableLetters) {
      let tokens = availableLettersTokenizer(availableLetters);
      // Sort to have an stable search, making all tiles of the same value
      // interchangable
      tokens.sort();
      console.log("Sorted tokens", tokens);
      console.log(WORD_LIST);
      let seen = new Set();
      let answers = treeSearchRecursive(
        WORD_TREE,
        tokens,
        seen,
        ""
      );
      console.log(answers);
    }

////////////////////////////////////////////////////////////////////////////////
// Word logic
////////////////////////////////////////////////////////////////////////////////

    function tileToLetters(tile) {
      let letterSeq = tile;
      if (letterSeq.length > 1) {
        letterSeq = tile.split('');
      } else if (tile == "*") {
        letterSeq = SEARCH_LETTERS;
      }
      return letterSeq;
    }

    function availableLettersTokenizer(availableLetters) {
      let resultTokens = [];
      availableLetters = availableLetters.toUpperCase();
      const splitAvailableLetters = availableLetters.split('');
      // Traverse the full array of characters
      for(let idx = 0; idx<splitAvailableLetters.length ; idx++) {
        let specialSeqFound = false;
        // Check at the current position if it is a special sequence
        for(const specialSeq of SPECIAL_SEQUENCES) {
          if (availableLetters.indexOf(specialSeq, idx) == idx) {
            // Add the special sequence to the result
            resultTokens.push(specialSeq);
            // Advance forward the extra letters
            idx += specialSeq.length -1;
            specialSeqFound = true;
            break;
          }
        }
        // If not a special sequence add the character to the list
        if (! specialSeqFound) {
          const curLet = splitAvailableLetters[idx];
          resultTokens.push(curLet);
        }
      }
      return resultTokens;
    }

    function validateWord(possibleWord) {
      if (possibleWord.length >= WORD_LENGTH_THRESHOLD) {
        // If the word is valid, add it to the list
        WORD_LIST.add(possibleWord);
        // Also add it to the tre of possibilities
        let currentWordTree = WORD_TREE;
        // The logic of the loop is just to generate the tree of
        // possibilities. For that letter by letter we add them
        // to the space linking forwards.
        for (wordletter of possibleWord) {
          if (! (wordletter in currentWordTree)) {
            currentWordTree[wordletter] = new Map();
          }
          currentWordTree = currentWordTree[wordletter];
        }
      }
    }

////////////////////////////////////////////////////////////////////////////////
// File loading logic
////////////////////////////////////////////////////////////////////////////////
    const filewordsinstance = document.getElementById("filewords");
    const filewordscountinstance = document.getElementById("filewordscount");
    filewordsinstance.addEventListener("change", filewordshandler);
    const fileprogressbarinstance = document.getElementById("fileprogressbar");

    // In this function we pre-process the file and optimize the information
    // into a format far more efficient for the processing we want to realize
    // with it.
    function processFileWords(rawtext) {
      let currentWord = "";
      for (let letter of rawtext) {
        if (VALID_LETTERS.has(letter)) {
          currentWord += letter;
        } else {
          validateWord(currentWord);
          currentWord = "";
        }
      }
      filewordscountinstance.innerHTML = WORD_LIST.size;
      // Uncomment the line after to see the tree structure of all the
      // letters and it's possible continuations.
      //console.log(WORD_TREE);
    }

    function processFileWordsCB(e) {
        processFileWords(e.target.result);
    }

    function readFileWords(file) {
      const info = `File Name: "${file.name}" File Size: ${file.size}B`;
      // Debug log just to confirm the correct data is being read
      //console.log(info);
      const reader = new FileReader();
      reader.onload = processFileWordsCB;
      reader.readAsText(file);
    }

    function filewordshandler(e) {
      WORD_TREE = new Map();
      WORD_LIST = new Set();
      const file = e.target.files[0];
      readFileWords(file);
    }

    // If already selected load the file
    if (filewordsinstance.files[0]) {
      readFileWords(filewordsinstance.files[0]);
    }

////////////////////////////////////////////////////////////////////////////////
// Display and event logic
////////////////////////////////////////////////////////////////////////////////
    const lineinputinstance = document.getElementById("lineinput");
    lineinputinstance.addEventListener("input", lineInputListener);

    const buttonlinessubmit = document.getElementById("linesubmit");
    buttonlinessubmit.onclick = lineInputSumbmit;
    const tabletilesinstance = document.getElementById("tabletiles");

    // Initializations from cached data
    lineInputGridDisplay(lineinputinstance.value);

    function lineInputSumbmit(e) {
      treeSearch(lineinputinstance.value);
    }

    function lineInputGridDisplay(availableLetters) {
      const LETTERS_LENGTH_LINE = 23;
      let rownum = 0;
      let colnum = 1;
      const gridLenght = 16;
      const colstart = 1;
      const colwidth = 5;

      let letters = availableLettersTokenizer(availableLetters);

      // Put the number of the position where there is no letter
      let counterPos = 1;

      // Fill the table
      for(let idx = 0; idx<gridLenght; idx++) {
        let ltr = counterPos++;
        if (idx < letters.length) {
          ltr = letters[idx];
        }
        tabletilesinstance.rows[rownum].cells[colnum++].innerHTML = ltr;
        if (colnum >= colwidth) {
          colnum = colstart;
          rownum++;
        }
      }

      // For the last 3 letters are the first column of the first three rows
      // For that, we manage them differently
      for(let idx=0; idx<3; idx++) {
        const pos=gridLenght+idx;
        let ltr = counterPos++;
        if(letters.length > pos) {
          ltr = letters[pos];
        }
        tabletilesinstance.rows[idx].cells[0].innerHTML = ltr;
      }

      // Limit the letter count, still thinking if this is too strict
      if(letters.length > LETTERS_LENGTH_LINE) {
        while(letters.length > LETTERS_LENGTH_LINE) {
          letters.pop();
        }
      }
      lineinputinstance.value = letters.join("");
    }

    function lineInputListener(e) {
      lineInputGridDisplay(e.target.value);
    }

    // Starts with tiles selector logic
    const starttilesselectorinstance = document.getElementById(
      "starttilesselector"
    );
    const startstilesinstance = document.getElementById("startstiles");
    starttilesselectorinstance.addEventListener("click",
      startsWithtilesHandler
    );
    function startsWithtilesHandler(e) {
      startstilesinstance.toggleAttribute("disabled");
      if (startstilesinstance.hasAttribute("disabled")) {
        startstilesinstance.value = "";
      }
    }

  </script>
</body>
</html>
